<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Animated A* (With Click-to-Select)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link
    href="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <style>
    html, body, #map { margin:0; padding:0; height:100% }
    #start-btn {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1;
      padding: 8px 12px;
      background: white;
      border: 1px solid #ccc;
      cursor: pointer;
      font-family: sans-serif;
    }
    #toggle-visited-btn {
  position: absolute;
  top: 50px;
  left: 10px;
  z-index: 1;
  padding: 8px 12px;
  background: white;
  border: 1px solid #ccc;
  cursor: pointer;
  font-family: sans-serif;
}
  </style>
</head>
<body>
  <div id="map"></div>
  <button id="start-btn">Start</button>
  <button id="toggle-visited-btn">Hide Visited Nodes</button>

  <script src="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: "https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL",
      center: [-75.7, 45.39],
      zoom: 13
    });
    map.addControl(new maplibregl.NavigationControl());
    map.on('load', () => {
      fetch('../../Data-Collection/large-ottawa-area.geojson')
        .then(res => res.json())
        .then(async geojson => {
          // --- build graph & ID/coord maps ---
          const graph = {};
          function key(pt){ return pt[0] + ',' + pt[1]; }
          geojson.features.forEach(f => {
            const c = f.geometry.coordinates;
            for (let i = 1; i < c.length; i++) {
              const A = key(c[i-1]), B = key(c[i]);
              const d = turf.distance(turf.point(c[i-1]), turf.point(c[i]), { units: 'kilometers' });
              graph[A] = graph[A] || [];
              graph[B] = graph[B] || [];
              graph[A].push({ to: B, weight: d });
              graph[B].push({ to: A, weight: d });
            }
          });

          const allKeys   = Object.keys(graph);
          const idMap     = Object.fromEntries(allKeys.map((k,i) => [k, i]));
          const coordsMap = Object.fromEntries(allKeys.map(k => [k, k.split(',').map(Number)]));

          // --- create visited-nodes source & layer ---
          const features = allKeys.map((k,i) => ({
            type: 'Feature',
            id: i,
            geometry: { type: 'Point', coordinates: coordsMap[k] },
            properties: {}
          }));
          map.addSource('visited-nodes', {
            type: 'geojson',
            data: { type:'FeatureCollection', features }
          });
          map.addLayer({
            id: 'visited-node-points',
            type: 'circle',
            source: 'visited-nodes',
            paint: {
              'circle-radius': 2,
              'circle-opacity': 1,
              'circle-stroke-width': .5,
              'circle-stroke-color': '#fff',
              'circle-color': [
                'case',
                ['==',['feature-state','visited'], true], '#FF851B',
                '#2ECC40'
              ]
            }
          });

          // --- initialize all to unvisited ---
          function resetVisited() {
            allKeys.forEach(k => {
              map.setFeatureState(
                { source: 'visited-nodes', id: idMap[k] },
                { visited: false }
              );
            });
          }
          resetVisited();

          // --- A* async generator ---
          async function* astarGen(graph, start, goal) {
            const h = u => turf.distance(
              turf.point(coordsMap[u]),
              turf.point(coordsMap[goal]),
              { units: 'kilometers' }
            );

            const openSet = new Set([start]);
            const cameFrom = {};
            const gScore = Object.fromEntries(allKeys.map(u => [u, Infinity]));
            const fScore = Object.fromEntries(allKeys.map(u => [u, Infinity]));
            gScore[start] = 0;
            fScore[start] = h(start);

            while (openSet.size) {
              let current = null, best = Infinity;
              for (const u of openSet) {
                if (fScore[u] < best) {
                  best = fScore[u]; current = u;
                }
              }
              yield current;
              if (current === goal) break;

              openSet.delete(current);
              for (const { to: neighbor, weight: w } of graph[current]) {
                const tentativeG = gScore[current] + w;
                if (tentativeG < gScore[neighbor]) {
                  cameFrom[neighbor] = current;
                  gScore[neighbor] = tentativeG;
                  fScore[neighbor] = tentativeG + h(neighbor);
                  if (!openSet.has(neighbor)) openSet.add(neighbor);
                }
              }
            }

            if (gScore[goal] === Infinity) return null;
            const path = [];
            let u = goal;
            while (u) { path.unshift(u); u = cameFrom[u]; }
            return path;
          }

          // --- allow user to click start/end ---
          let startKey = null, endKey = null;
          let startMarker, endMarker;
          map.on('click', (e) => {
            const click = [e.lngLat.lng, e.lngLat.lat];
            // find nearest graph node (brute-force)
            let best = Infinity, nearest = null;
            allKeys.forEach(k => {
              const c = coordsMap[k];
              const dx = click[0] - c[0], dy = click[1] - c[1];
              const d2 = dx*dx + dy*dy;
              if (d2 < best) { best = d2; nearest = k; }
            });
            if (!startKey) {
              startKey = nearest;
              startMarker = new maplibregl.Marker({ color: 'green' })
                .setLngLat(coordsMap[nearest]).addTo(map);
            } else if (!endKey) {
              endKey = nearest;
              endMarker = new maplibregl.Marker({ color: 'red' })
                .setLngLat(coordsMap[nearest]).addTo(map);
            }
          });

          // --- hook up Start button ---
          document.getElementById('start-btn').addEventListener('click', async () => {
            if (!startKey || !endKey) {
              return alert('Please click once for start (green), then once for end (red).');
            }
            // reset old visuals
            resetVisited();
            if (startMarker) startMarker.remove();
            if (endMarker)   endMarker.remove();
            // show markers again
            startMarker = new maplibregl.Marker({ color: 'green' })
              .setLngLat(coordsMap[startKey]).addTo(map);
            endMarker = new maplibregl.Marker({ color: 'red' })
              .setLngLat(coordsMap[endKey]).addTo(map);

            const btn = document.getElementById('start-btn');
            btn.disabled = true;
            btn.textContent = 'Runningâ€¦';

            // run & animate
            const gen = astarGen(graph, startKey, endKey);
            let step, batch = [];
            while (!(step = await gen.next()).done) {
              batch.push(step.value);
              if (batch.length >= 50) {
                batch.forEach(k => {
                  map.setFeatureState(
                    { source: 'visited-nodes', id: idMap[k] },
                    { visited: true }
                  );
                });
                batch.length = 0;
                await new Promise(r => setTimeout(r, 0));
              }
            }
            // flush remainder
            batch.forEach(k => {
              map.setFeatureState(
                { source: 'visited-nodes', id: idMap[k] },
                { visited: true }
              );
            });

            const path = step.value;
            if (!path) return console.warn('No path found!');
            // draw final path
            const coords = path.map(k => coordsMap[k]);
            if (map.getSource('shortest-path')) {
              map.getSource('shortest-path').setData({
                type:'FeatureCollection',
                features:[{ type:'Feature', geometry:{ type:'LineString', coordinates:coords } }]
              });
            } else {
              map.addSource('shortest-path', {
                type:'geojson',
                data: {
                  type:'FeatureCollection',
                  features: [{ type:'Feature', geometry:{ type:'LineString', coordinates:coords }, properties:{} }]
                }
              });
              map.addLayer({
                id: 'shortest-path-line',
                type: 'line',
                source: 'shortest-path',
                layout: { 'line-join':'round','line-cap':'round' },
                paint: { 'line-color':'#0074D9','line-width':4 }
              });
            }

            btn.textContent = 'Done';
          });

          // keep track of whether the layer is visible
let visitedVisible = true;

// wire up the toggle button
const toggleBtn = document.getElementById('toggle-visited-btn');
toggleBtn.addEventListener('click', () => {
  visitedVisible = !visitedVisible;
  map.setLayoutProperty(
    'visited-node-points',
    'visibility',
    visitedVisible ? 'visible' : 'none'
  );
  toggleBtn.textContent = visitedVisible
    ? 'Hide Visited Nodes'
    : 'Show Visited Nodes';
});

        })
        .catch(console.error);
    });
  </script>
</body>
</html>
