<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Animated A* (Optimized)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link
    href="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <style>
    html, body, #map { margin:0; padding:0; height:100% }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: "https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL",
      center: [-75.7, 45.39],
      zoom: 13
    });
    map.addControl(new maplibregl.NavigationControl());

    map.on('load', () => {
      fetch('../Data-Collection/medium.geojson')
        .then(res => res.json())
        .then(async geojson => {
          // --- build graph & ID/coord maps ---
          const graph = {};
          function key(pt){ return pt[0] + ',' + pt[1]; }
          geojson.features.forEach(f => {
            const c = f.geometry.coordinates;
            for (let i = 1; i < c.length; i++) {
              const A = key(c[i-1]), B = key(c[i]);
              const d = turf.distance(turf.point(c[i-1]), turf.point(c[i]), { units: 'kilometers' });
              graph[A] = graph[A] || [];
              graph[B] = graph[B] || [];
              graph[A].push({ to: B, weight: d });
              graph[B].push({ to: A, weight: d });
            }
          });

          const allKeys = Object.keys(graph);
          const idMap   = Object.fromEntries(allKeys.map((k,i) => [k, i]));
          const coordsMap = Object.fromEntries(
            allKeys.map(k => [k, k.split(',').map(Number)])
          );

          // --- create visited-nodes source & layer ---
          const features = allKeys.map((k,i) => ({
            type: 'Feature',
            id: i,
            geometry: { type: 'Point', coordinates: coordsMap[k] },
            properties: {}
          }));
          map.addSource('visited-nodes', {
            type: 'geojson',
            data: { type:'FeatureCollection', features }
          });
          map.addLayer({
            id: 'visited-node-points',
            type: 'circle',
            source: 'visited-nodes',
            paint: {
              'circle-radius': 3,
              'circle-opacity': 1,
              'circle-stroke-width': 1,
              'circle-stroke-color': '#fff',
              'circle-color': [
                'case',
                ['==',['feature-state','visited'], true], '#FF851B',
                '#2ECC40'
              ]
            }
          });

          // --- initialize all to unvisited ---
          allKeys.forEach(k => {
            map.setFeatureState(
              { source: 'visited-nodes', id: idMap[k] },
              { visited: false }
            );
          });

          // --- A* async generator ---
          async function* astarGen(graph, start, goal) {
            // heuristic: straight-line distance
            const h = (u) => turf.distance(
              turf.point(coordsMap[u]),
              turf.point(coordsMap[goal]),
              { units: 'kilometers' }
            );

            const openSet = new Set([start]);
            const cameFrom = {};
            const gScore = Object.fromEntries(allKeys.map(u => [u, Infinity]));
            const fScore = Object.fromEntries(allKeys.map(u => [u, Infinity]));
            gScore[start] = 0;
            fScore[start] = h(start);

            while (openSet.size) {
              // pick node in openSet with lowest fScore
              let current = null;
              let best = Infinity;
              for (const u of openSet) {
                if (fScore[u] < best) {
                  best = fScore[u];
                  current = u;
                }
              }
              yield current;
              if (current === goal) break;

              openSet.delete(current);
              for (const { to: neighbor, weight: w } of graph[current]) {
                const tentativeG = gScore[current] + w;
                if (tentativeG < gScore[neighbor]) {
                  cameFrom[neighbor] = current;
                  gScore[neighbor] = tentativeG;
                  fScore[neighbor] = tentativeG + h(neighbor);
                  if (!openSet.has(neighbor)) {
                    openSet.add(neighbor);
                  }
                }
              }
            }

            if (gScore[goal] === Infinity) return null;
            const path = [];
            let u = goal;
            while (u) {
              path.unshift(u);
              u = cameFrom[u];
            }
            return path;
          }

          // --- run & animate ---
          const startKey = key(geojson.features[0].geometry.coordinates[0]);
          const lastPt = geojson.features.at(-1).geometry.coordinates.slice(-1)[0];
          const endKey = key(lastPt);
          const gen    = astarGen(graph, startKey, endKey);

          let step, batch = [];
          while (!(step = await gen.next()).done) {
            batch.push(step.value);
            if (batch.length >= 50) {
              batch.forEach(k => {
                map.setFeatureState(
                  { source: 'visited-nodes', id: idMap[k] },
                  { visited: true }
                );
              });
              batch.length = 0;
              await new Promise(r => setTimeout(r, 0));
            }
          }
          // flush any remainder
          batch.forEach(k => {
            map.setFeatureState(
              { source: 'visited-nodes', id: idMap[k] },
              { visited: true }
            );
          });

          const shortest = step.value;
          if (!shortest) return console.warn('no path');

          // --- draw final path ---
          const pathCoords = shortest.map(k => coordsMap[k]);
          map.addSource('shortest-path', {
            type: 'geojson',
            data: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                geometry: { type: 'LineString', coordinates: pathCoords },
                properties: {}
              }]
            }
          });
          map.addLayer({
            id: 'shortest-path-line',
            type: 'line',
            source: 'shortest-path',
            layout: { 'line-join':'round','line-cap':'round' },
            paint: { 'line-color':'#0074D9','line-width':4 }
          });
        })
        .catch(console.error);
    });
  </script>
</body>
</html>
