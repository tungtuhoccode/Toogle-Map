<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Animated A* (With Click-to-Select and Animated Visited)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link
    href="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <style>
    html, body, #map { margin:0; padding:0; height:100%; }
    #start-btn, #toggle-visited-btn {
      position: absolute;
      left: 10px;
      z-index: 1;
      padding: 8px 12px;
      background: white;
      border: 1px solid #ccc;
      cursor: pointer;
      font-family: sans-serif;
    }
    #start-btn { top: 10px; }
    #toggle-visited-btn { top: 50px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <button id="start-btn">Start</button>
  <button id="toggle-visited-btn">Hide Visited Nodes</button>

  <script src="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    // 1) initialize map
    const map = new maplibregl.Map({
      container: 'map',
      style: "https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL",
      center: [-75.7, 45.39],
      zoom: 13,
    });
    map.addControl(new maplibregl.NavigationControl());

    map.on('load', () => {
      // 2) fetch geojson then hand off to worker
      //   fetch('../../Data-Collection/super-huge.geojson')
      fetch('../../Data-Collection/medium-ottawa-area.geojson')
        .then(res => {
          const len = res.headers.get('content-length');
          if (len) console.log(`On the wire: ${len} bytes`);
          return res.json();
        })
        .then(geojson => {
          console.log("finish loading json")
          const worker = new Worker('graphWorker.js');
          worker.postMessage(geojson);
          geojson = null; //discard geojson from memory

          worker.onmessage = ({ data }) => {
            console.log("finish loading");
            const { graph, coordsMap, allKeys } = data;
            worker.terminate();

            // // helper to get UTF-8 byte length of any JS value
            // function byteSize(obj) {
            //   // stringify → UTF-8 encode → measure length
            //   return new TextEncoder().encode(JSON.stringify(obj)).length;
            // }

            // console.log(`graph:      ~${byteSize(graph).toLocaleString()} bytes`);
            // console.log(`coordsMap:  ~${byteSize(coordsMap).toLocaleString()} bytes`);
            // console.log(`allKeys:    ~${byteSize(allKeys).toLocaleString()} bytes`);

            // build graph-nodes source + cluster layers
            let features = allKeys.map((k, i) => ({
              type: 'Feature',
              id: i,
              geometry: { type: 'Point', coordinates: coordsMap[k] },
              properties: {}
            }));

            console.log("Number of nodes", features.length)
            map.addSource('graph-nodes', {
              type: 'geojson',
              data: { type: 'FeatureCollection', features },
              cluster: true,
              clusterMaxZoom: 16,
              clusterRadius: 2
            });

            features = null; //free up feature memory

            map.addLayer({
              id: 'clusters', type: 'circle', source: 'graph-nodes',
              filter: ['has', 'point_count'],
              paint: {
                'circle-radius': 2,
                'circle-color': '#2ECC40',
                'circle-stroke-width': 1,
                'circle-stroke-color': '#fff'
              }
            });
            map.addLayer({
              id: 'unclustered-point', type: 'circle', source: 'graph-nodes',
              filter: ['!', ['has', 'point_count']],
              paint: {
                'circle-radius': 2,
                'circle-color': '#2ECC40',
                'circle-stroke-width': 1,
                'circle-stroke-color': '#fff'
              }
            });



            // click to pick start/end
            let startKey = null, endKey = null;
            let startMarker, endMarker;
            
            map.on('click', e => {
              const click = [e.lngLat.lng, e.lngLat.lat];
              let best = Infinity, nearest = null;
              allKeys.forEach(k => {
                const [x,y] = coordsMap[k];
                const d2 = (click[0]-x)**2 + (click[1]-y)**2;
                if (d2 < best) { best = d2; nearest = k; }
              });
              if (!startKey) {
                startKey = nearest;
                startMarker = new maplibregl.Marker({ color:'green' })
                  .setLngLat(coordsMap[nearest]).addTo(map);
              } else if (!endKey) {
                endKey = nearest;
                endMarker = new maplibregl.Marker({ color:'red' })
                  .setLngLat(coordsMap[nearest]).addTo(map);
              }
            });

            // 6) run A*, animate visited + draw path
            document.getElementById('start-btn')
              .addEventListener('click', async () => {
                if (!startKey || !endKey) {
                  return alert('Click for start (green) then end (red).');
                }
                startMarker?.remove(); endMarker?.remove();
                startMarker = new maplibregl.Marker({ color:'green' })
                  .setLngLat(coordsMap[startKey]).addTo(map);
                endMarker   = new maplibregl.Marker({ color:'red' })
                  .setLngLat(coordsMap[endKey]).addTo(map);

                const btn = document.getElementById('start-btn');
                btn.disabled = true; btn.textContent = 'Running…';
                console.log("Start running algorithm")

                const aStarAlgorithmWorker = new Worker('aStarAlgorithmWorker.js');

                 // 2) Kick it off and await its response
                    const { visitedOrder, path } = await new Promise(resolve => {
                    aStarAlgorithmWorker.onmessage = ({ data }) => {
                        resolve(data);
                        worker.terminate();       // clean up the worker
                    };
                    aStarAlgorithmWorker.postMessage({       // send it everything it needs
                        graph,
                        coordsMap,
                        allKeys,
                        startKey,
                        endKey
                    });
                    });

                    console.log("Worker finished, now visualize…");

                // map.triggerRepaint()
                console.log("added visualization data to map")
                console.log(visitedOrder)
//!#($&(*#!$&(*!#)))
  // … all your existing map initialization, graph loading, A* worker, etc.

  // 1) AFTER you get `visitedOrder` back from your worker:
  const visitedCoords = visitedOrder.map(s => {
    const [lng, lat] = s.split(',').map(Number);
    return [lng, lat];
  });
  let animating = true;  // flip to false when you want to stop redrawing

  console.log("start drawing using viisted layer")
  // 2) define your custom “visited-custom” layer exactly once (e.g. right after map.load)
map.addLayer({
  id: 'visited-custom',
  type: 'custom',
  renderingMode: '2d',

  onAdd(map, gl) {
    // 1) Minimal vertex+fragment shaders, no attributes:
    const vs = `
      precision mediump float;
      uniform vec2 u_point;
      uniform float u_radius;
      uniform mat4 u_matrix;
      void main() {
        // position in clip space
        gl_Position = u_matrix * vec4(u_point, 0.0, 1.0);
        // size in pixels
        gl_PointSize = u_radius * 2.0;
      }
    `;
    const fs = `
      precision mediump float;
      void main() {
        // a simple solid circle: use the fragment mask
        vec2 coord = gl_PointCoord * 2.0 - 1.0;
        if (dot(coord, coord) > 1.0) discard;
        gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0);
      }
    `;

    // compile & link
    const prog = gl.createProgram();
    [['VERTEX_SHADER', vs], ['FRAGMENT_SHADER', fs]].forEach(([type, src]) => {
      const s = gl.createShader(gl[type]);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      gl.attachShader(prog, s);
    });
    gl.linkProgram(prog);

    // look up uniform locations
    this.prog = {
      program: prog,
      u_point:  gl.getUniformLocation(prog, 'u_point'),
      u_matrix: gl.getUniformLocation(prog, 'u_matrix'),
      u_radius: gl.getUniformLocation(prog, 'u_radius'),
    };

    // enable alpha blending for smooth circles
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  },

  render(gl, matrix) {
    if (!visitedCoords.length) return;

    gl.useProgram(this.prog.program);

    // build a real Float32Array from MapLibre's matrix
    const m = new Float32Array(16);
    for (let i = 0; i < 16; i++) m[i] = matrix[i];
    gl.uniformMatrix4fv(this.prog.u_matrix, false, m);

    // draw only the first visited point for debugging
    const [lng, lat] = visitedCoords[0];
    const p = map.project([lng, lat]);
    gl.uniform2f(this.prog.u_point, p.x, p.y);
    gl.uniform1f(this.prog.u_radius, 100.0);  // 8px radius → 16px diameter

    // this will draw one POINT and rely on gl_PointSize
    gl.drawArrays(gl.POINTS, 0, 1);
    // no need to trigger another repaint unless you’re animating continuously
  }
});

//!#($&(*#!$&(*!#)))

              
                if (path) {
                  const coords = path.map(k => coordsMap[k]);
                  const fc = { type:'FeatureCollection', features:[{
                    type:'Feature', geometry:{ type:'LineString', coordinates: coords }, properties:{}
                  }]};
                  if (map.getSource('shortest-path')) {
                    map.getSource('shortest-path').setData(fc);
                  } else {
                    map.addSource('shortest-path',{ type:'geojson', data: fc });
                    map.addLayer({
                      id: 'shortest-path-line', type: 'line', source: 'shortest-path',
                      layout: { 'line-join':'round','line-cap':'round' },
                      paint: { 'line-color':'#0074D9','line-width':4 }
                    });
                  }
                } else {
                  console.warn('No path found!');
                }

              });


            // toggle visited-trail visibility
            let visitedVisible = true;
            document.getElementById('toggle-visited-btn')
              .addEventListener('click', () => {
                visitedVisible = !visitedVisible;
                map.setLayoutProperty(
                  'unclustered-point','visibility',
                  visitedVisible ? 'visible':'none'
                );
                map.setLayoutProperty(
                'clusters','visibility',
                  visitedVisible ? 'visible':'none'
                );

                 if (map.getLayer('visited-clusters-2')) {
                        map.setLayoutProperty(
                  'visited-clusters-2','visibility',
                  visitedVisible ? 'visible':'none'
                );
                map.setLayoutProperty(
                'visited-unclustered-2','visibility',
                  visitedVisible ? 'visible':'none'
                );
                 }
                document.getElementById('toggle-visited-btn').textContent =
                  visitedVisible ? 'Hide Visited Nodes':'Show Visited Nodes';
              });
          };
        })
        .catch(console.error);
    });
  </script>
</body>
</html>
