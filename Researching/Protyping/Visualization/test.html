<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Interactive Dijkstra Visualization</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link
    href="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <style>
    html, body, #map { margin:0; padding:0; height:100% }
    #controls {
      position: absolute;
      top: 10px; left: 10px;
      z-index: 1;
      background: white;
      padding: 6px;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    }
    #controls button { margin-right: 4px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <button id="startBtn" disabled>Start</button>
  </div>

  <script src="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: "https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL",
      center: [-75.7, 45.39],
      zoom: 13
    });
    map.addControl(new maplibregl.NavigationControl());

    map.on('load', async () => {
      // 1️⃣ Load and build graph
      const geojson = await fetch('../../Data-Collection/medium.geojson').then(r=>r.json());
      const graph = {};
      function key(pt){ return pt[0] + ',' + pt[1]; }
      geojson.features.forEach(f => {
        const c = f.geometry.coordinates;
        for(let i=1; i<c.length; i++){
          const A = key(c[i-1]), B = key(c[i]);
          const d = turf.distance(turf.point(c[i-1]), turf.point(c[i]), { units:'kilometers' });
          graph[A] = graph[A]||[];
          graph[B] = graph[B]||[];
          graph[A].push({ to: B, weight: d });
          graph[B].push({ to: A, weight: d });
        }
      });

      const allKeys   = Object.keys(graph);
      const idMap     = Object.fromEntries(allKeys.map((k,i)=>[k,i]));
      const coordsMap = Object.fromEntries(allKeys.map(k=>[k, k.split(',').map(Number)]));

      // 2️⃣ Add visited-nodes source & layer
      const features = allKeys.map((k,i)=>({
        type:'Feature',
        id: i,
        geometry:{ type:'Point', coordinates: coordsMap[k] },
        properties:{}
      }));
      map.addSource('visited-nodes', {
        type: 'geojson',
        data: { type:'FeatureCollection', features }
      });
      map.addLayer({
        id: 'visited-node-points',
        type: 'circle',
        source: 'visited-nodes',
        paint: {
          'circle-radius': 3,
          'circle-stroke-width': 1,
          'circle-stroke-color': '#fff',
          'circle-color': [
            'case',
            ['==',['feature-state','visited'], true], '#FF851B',
            '#2ECC40'
          ]
        }
      });
      // initialize all to unvisited
      allKeys.forEach(k=>{
        map.setFeatureState(
          { source:'visited-nodes', id: idMap[k] },
          { visited: false }
        );
      });

      // 3️⃣ Selection logic
      let selectionCount = 0;
      let startLngLat, endLngLat;
      let startMarker, endMarker;
      map.on('click', e => {
        if (selectionCount === 0) {
          startLngLat = [e.lngLat.lng, e.lngLat.lat];
          startMarker = new maplibregl.Marker({ color: 'green' })
            .setLngLat(startLngLat)
            .addTo(map);
          selectionCount++;
        } else if (selectionCount === 1) {
          endLngLat = [e.lngLat.lng, e.lngLat.lat];
          endMarker = new maplibregl.Marker({ color: 'red' })
            .setLngLat(endLngLat)
            .addTo(map);
          selectionCount++;
          document.getElementById('startBtn').disabled = false;
        }
      });

      // helper: snap a click to nearest graph node
      function findNearest([lng, lat]) {
        let best = Infinity, bestKey = null;
        allKeys.forEach(k => {
          const [x,y] = coordsMap[k];
          const dx = x - lng, dy = y - lat;
          const dist2 = dx*dx + dy*dy;
          if (dist2 < best) {
            best = dist2;
            bestKey = k;
          }
        });
        return bestKey;
      }

      // 4️⃣ Dijkstra generator
      async function* dijkstraGen(g, start, goal) {
        const dist = Object.fromEntries(allKeys.map(u=>[u,Infinity]));
        const prev = {};
        dist[start] = 0;
        const Q = Object.keys(g);
        while (Q.length) {
          Q.sort((a,b)=>dist[a]-dist[b]);
          const u = Q.shift();
          yield u;
          if (u === goal) break;
          for(const {to:v,weight:w} of g[u]) {
            const alt = dist[u] + w;
            if (alt < dist[v]) {
              dist[v] = alt;
              prev[v] = u;
            }
          }
        }
        if (dist[goal] === Infinity) return null;
        const path = [];
        let u = goal;
        while(u) { path.unshift(u); u = prev[u]; }
        return path;
      }

      // 5️⃣ Start button logic
      document.getElementById('startBtn').addEventListener('click', async () => {
        document.getElementById('startBtn').disabled = true;
        const startKey = findNearest(startLngLat);
        const endKey   = findNearest(endLngLat);
        const gen      = dijkstraGen(graph, startKey, endKey);

        // animate in batches of 50
        let step, batch = [];
        while (!(step = await gen.next()).done) {
          batch.push(step.value);
          if (batch.length >= 50) {
            batch.forEach(k => {
              map.setFeatureState(
                { source:'visited-nodes', id: idMap[k] },
                { visited: true }
              );
            });
            batch.length = 0;
            await new Promise(r => setTimeout(r, 0));
          }
        }
        // flush remainder
        batch.forEach(k => {
          map.setFeatureState(
            { source:'visited-nodes', id: idMap[k] },
            { visited: true }
          );
        });

        const shortest = step.value;
        if (!shortest) return console.warn('no path');

        // draw final path
        const coords = shortest.map(k=>coordsMap[k]);
        map.addSource('shortest-path', {
          type:'geojson',
          data: {
            type:'FeatureCollection',
            features: [{
              type:'Feature',
              geometry:{type:'LineString',coordinates:coords},
              properties:{}
            }]
          }
        });
        map.addLayer({
          id:'shortest-path-line',
          type:'line',
          source:'shortest-path',
          layout:{'line-join':'round','line-cap':'round'},
          paint:{'line-color':'#0074D9','line-width':4}
        });
      });

    });
  </script>
</body>
</html>
