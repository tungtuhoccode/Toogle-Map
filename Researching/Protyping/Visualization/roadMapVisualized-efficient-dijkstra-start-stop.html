<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Animated Dijkstra (Forced Unvisited State)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link
    href="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <style>
    html, body, #map { margin:0; padding:0; height:100% }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: "https://api.maptiler.com/maps/streets/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL",
      center: [-75.7, 45.39],
      zoom: 13
    });
    map.addControl(new maplibregl.NavigationControl());

    map.on('load', () => {
      fetch('../../Data-Collection/small.geojson')
        .then(res => res.json())
        .then(async geojson => {
          // --- build graph & ID map ---
          const graph = {};
          function key(pt){ return pt[0]+','+pt[1]; }
          geojson.features.forEach(f => {
            const c = f.geometry.coordinates;
            for(let i=1;i<c.length;i++){
              const A = key(c[i-1]), B = key(c[i]);
              const d = turf.distance(turf.point(c[i-1]), turf.point(c[i]), {units:'kilometers'});
              graph[A] = graph[A]||[];
              graph[B] = graph[B]||[];
              graph[A].push({to:B, weight:d});
              graph[B].push({to:A, weight:d});
            }
          });
          const allKeys = Object.keys(graph);
          const idMap   = Object.fromEntries(allKeys.map((k,i)=>[k,i]));

          // --- create the visited-nodes source & layer ---
          const features = allKeys.map((k,i)=>{
            const [lon,lat] = k.split(',').map(Number);
            return { type:'Feature', id:i, geometry:{type:'Point',coordinates:[lon,lat]}, properties:{} };
          });
          
          console.log(features)
          map.addSource('visited-nodes', {
            type:'geojson',
            data:{ type:'FeatureCollection', features }
          });
          map.addLayer({
            id: 'visited-node-points',
            type: 'circle',
            source: 'visited-nodes',
            paint: {
              'circle-radius': 3,
              'circle-opacity': 1,
              'circle-stroke-width':1,
              'circle-stroke-color':'#fff',
              'circle-color': [
                'case',
                ['==',['feature-state','visited'], true], '#FF851B',  // visited → orange
                '#2ECC40'                                             // unvisited → green
              ]
            }
          });

          // --- initialize every feature-state to visited=false ---
          allKeys.forEach(k => {
            map.setFeatureState(
              { source:'visited-nodes', id: idMap[k] },
              { visited: false }
            );
          });

          // --- rest of your Dijkstra + animation logic ---
          // (no changes here; you still call setFeatureState(..., {visited:true}) as you visit)
          async function* dijkstraGen(g, start, goal){
            const dist = Object.fromEntries(Object.keys(g).map(u=>[u,Infinity]));
            const prev = {};
            dist[start] = 0;
            const Q = Object.keys(g);
            while(Q.length){
              Q.sort((a,b)=>dist[a]-dist[b]);
              const u = Q.shift();
              yield u;
              if(u===goal) break;
              for(const {to:v,weight:w} of g[u]){
                const alt = dist[u]+w;
                if(alt<dist[v]){ dist[v]=alt; prev[v]=u; }
              }
            }
            if(dist[goal]===Infinity) return null;
            const path = [];
            for(let u=goal; u; u=prev[u]) path.unshift(u);
            return path;
          }

          const startKey = key(geojson.features[0].geometry.coordinates[0]);
          const endKey   = key(geojson.features.at(-1).geometry.coordinates.slice(-1)[0]);
          const gen      = dijkstraGen(graph, startKey, endKey);
          let step, batch=[];

          while(!(step = await gen.next()).done){
            batch.push(step.value);
            if(batch.length >= 50){
              batch.forEach(k => {
                map.setFeatureState(
                  { source:'visited-nodes', id: idMap[k] },
                  { visited: true }
                );
              });
              batch.length = 0;
              await new Promise(r => setTimeout(r, 0));
            }
          }
          // flush remainder
          batch.forEach(k => {
            map.setFeatureState(
              { source:'visited-nodes', id: idMap[k] },
              { visited: true }
            );
          });

          const shortest = step.value;
          if(!shortest) return console.warn('no path');
          const pathCoords = shortest.map(k=>k.split(',').map(Number));
          map.addSource('shortest-path', {
            type:'geojson',
            data:{ type:'FeatureCollection', features:[{
              type:'Feature',
              geometry:{type:'LineString',coordinates:pathCoords},
              properties:{}
            }] }
          });
          map.addLayer({
            id:'shortest-path-line',
            type:'line',
            source:'shortest-path',
            layout:{'line-join':'round','line-cap':'round'},
            paint:{'line-color':'#0074D9','line-width':4}
          });
        })
        .catch(console.error);
    });
  </script>
</body>
</html>
